1. What is RestMVC

RestMvc is a simple library for building RESTful services in ASP.NET MVC.
It's primary purpose is to provide routing and content negotiation (conneg).
The routing differs from other RESTful routing libraries, like SimplyRestful,
in that the route is defined alongside the action that receives the route.
It was largely inspired by the Ruby framework Sinatra (http://www.sinatrarb.com/).

2. Examples

public class OrdersController : Controller
{
    [Get("/orders")]
    public ActionResult Index() { ... }

    [Post("/orders"]
    public ActionResult Create() { ... }

    [Get("/orders/{id}.format", "/orders/{id}")]
    public ActionResult Show(string id, string format) { ... }
}

// In Global.asax.cs
RouteTable.Routes.Map<OrdersController>();

The code above will do the following:
* Create the three routes defined by the HTTP methods and URI templates in the attributes.
  Even though System.Web.Routing does not allow you to prefix URI templates with either
  / or ~/, I find allowing those prefixes can enhance readability, and thus they are allowed.
* Route HEAD and OPTIONS methods for the two URI templates ("orders" and "orders/{id}")
  to a method capable of handling those methods intelligently.
* Route the remaining (non-WebDAV) methods for both URI templates to a method
  that knows to return a 405 HTTP status code (Method Not Supported) with an appropriate
  Allow header.  This method and the ones that handle HEAD and OPTIONS are defined as virtual
  on RestfulController.  If you want them mapped by RestMvc, but want to customize them
  (e.g., adding a body on OPTIONS), you can subclass RestfulController and override the
  appropriate methods.
* Notice the optional format parameter on the GET method actions (Show uses it;
  Index does not).  Routes with an extension are routed such that the extension
  gets passed as the format parameter, if the resource supports multiple representations
  (e.g. /orders/1.xml routes to Show with a format of xml)
  
The last point is a convenient way to handle multiple formats for a resource.  Since
it's in the URL, it can be bookmarked and emailed, with the same representation
regardless of the HTTP headers.  Even if content negotiation is used, it allows
you to bypass the standard negotiation process.  RestMvc does not automatically
provide these routes for you - notice that two URIs are specified on the Show method,
and the order is important, since /orders/123.xml would also match /orders/{id} (id = 123.xml).

Content negotiation is provided as a decorator to the standard RouteHandler.
One of the problems I've seen with some other RESTful routing libraries is that
they define the IRouteHandler internally, which removes your ability to add
any custom hooks into the routing process.  My hope is that providing the
functionality as a decorator provides more flexibility.

// In Global.asax.cs
var map = new MediaTypeFormatMap();
map.Add("text/html", "html");
map.Add("application/xml", xml");
map.Add("text/xml", "xml");

var connegRouter = new SimpleContentNegotiationRouteProxy(new MvcRouteHandler(), map);

RouteTable.Routes.Map<OrdersController>(connegRouter);

In the absence of a route URI template specifying the format explicitly,
the connegDecorator will examine the Accept request header and pick the
first media type supported in the map.  If no Accept header is sent,
or it is any of text/html, text/*, or */*, then the html format will be
added to the route data, and can be added to the controller action as a
parameter.  If none of those accept types are sent, it tries to match
the next entry in map (application/xml).  If no matches are found,
the default format is used (html in this example).

3. Building RestMVC

Hopefully, build.bat should do the trick.  RestMVC uses CM.NET,
a build library I've developed hosted at http://github.com/bbyars/CM.NET.
The output should be placed in the build directory.

The build will install the RestMvc.Example project as a virtual directory
under the Default Web Site and run some functional tests against it.
I believe the functional tests will only work on IIS 7 - I think
we would need to add a wildcard script map accepting all HTTP verbs
on previous versions of IIS.

build.bat /t:Coverage should spit out test coverage in the build directory.

4. Contributing

Patches and suggestions are always welcome.  You can reach me at brandon.byars@gmail.com.
Feel free to fork the repository at http://github.com/bbyars/RestMvc.
