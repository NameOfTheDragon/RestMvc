1. What is RestMVC

RestMvc is a simple library for building RESTful services in ASP.NET MVC.
It's primary purpose is to provide routing and content negotiation (conneg).
The routing differs from other RESTful routing libraries, like SimplyRestful,
in that the route is defined alongside the action that receives the route.
It was largely inspired by the Ruby framework Sinatra (http://www.sinatrarb.com/).

2. Examples

public class OrdersController : RestfulController
{
    [Get("orders")]
    public ActionResult Index() { ... }

    [Post("orders"]
    public ActionResult Create() { ... }

    [Get("orders/{id}")]
    public ActionResult Show(string id, string format) { ... }
}

// In Global.asax.cs
RouteTable.Routes.Map<OrdersController>();

The code above will do the following:
* Create the three routes defined by the HTTP methods and URI templates in the attributes
* Route HEAD and OPTIONS methods for the two URI templates ("orders" and "orders/{id}")
  to a superclass method capable of handling those methods intelligently.
* Route the remaining (non-WebDAV) methods for both URI templates to a superclass method
  that knows to return a 405 HTTP status code (Method Not Supported).
* Notice the optional format parameter on the GET method actions (Show uses it;
  Index does not).  Routes with an extension are routed such that the extension
  gets passed as the format parameter, if the resource supports multiple representations
  (e.g. /orders/1.xml routes to Show with a format of xml)
  
The last point is a convenient way to handle multiple formats for a resource.  Since
it's in the URL, it can be bookmarked and emailed, with the same representation
regardless of the HTTP headers.  Even if content negotiation is used, it allows
you to bypass the standard negotiation process.

Content negotiation is provided as a decorator to the standard RouteHandler:

// In Global.asax.cs
var map = new MediaTypeFormatMap();
map.Add("text/html", "html");
map.Add("application/xml", xml");
map.Add("text/xml", "xml");

var baseHandler = new MvcRouteHandler();
var connegDecorator = new ContentNegotiationRouteProxy(baseHandler, map);

RouteTable.Routes.Map<OrdersController>();

In the absence of a URL extension specifying the format, the connegDecorator
will examine the Accept request header and pick the first entry in map
that matches _any_ media type in the Accept header (a fairly primitive
negotiation).  If no Accept header is sent, or it is any of text/html,
text/*, or */*, then the html format will be added to the route data,
and can be added to the controller action as a parameter (GET methods
only).  If none of those accept types are sent, it tries to match
the next entry in map (application/xml).  If no matches are found,
the default format is used (html in this example).

3. Building RestMVC

Hopefully, build.bat should do the trick.  RestMVC uses CM.NET,
a build library I've developed hosted at http://github.com/bbyars/CM.NET

4. Contributing

Patches and suggestions are always welcome.  You can reach me at brandon.byars@gmail.com.
Feel free to fork the repository at http://github.com/bbyars/RestMvc.
